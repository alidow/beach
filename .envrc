#!/usr/bin/env bash
# Auto-load host-specific env vars whenever a shell enters the repo.
# Requires direnv (https://direnv.net). After installing direnv and
# running `direnv allow` once, this script will keep BEACH_ICE_PUBLIC_IP
# in sync with the host's LAN IP so dockerized beach-manager can publish
# a reachable ICE candidate without manual edits to .env files.

set -euo pipefail

is_bad_ip() {
	local ip="$1"
	[[ -z "$ip" ]] && return 0
	case "$ip" in
		127.*|0.0.0.0) return 0 ;;
		192.168.65.*) return 0 ;;
		172.17.*|172.18.*|172.19.*) return 0 ;;
		172.1[0-6].*) return 0 ;;
	esac
	return 1
}

detect_host_ip() {
	local candidate=""
	local value=""

	# macOS: prefer Wi-Fi/Ethernet interfaces.
	if command -v ipconfig >/dev/null 2>&1; then
		for iface in en0 en1 en2; do
			value=$(ipconfig getifaddr "$iface" 2>/dev/null || true)
			if [[ -n "$value" ]] && ! is_bad_ip "$value"; then
				candidate="$value"
				break
			fi
		done
	fi

	# Linux: derive the source IP that would reach the public Internet.
	if [[ -z "$candidate" ]] && command -v ip >/dev/null 2>&1; then
		value=$(ip route get 1.1.1.1 2>/dev/null | awk '/src/ {print $7; exit}')
		if [[ -n "$value" ]] && ! is_bad_ip "$value"; then
			candidate="$value"
		fi
	fi

	# hostname -I fallback (Linux) or future methods.
	if [[ -z "$candidate" ]] && command -v hostname >/dev/null 2>&1; then
		value=$(hostname -I 2>/dev/null | awk '{print $1}')
		if [[ -n "$value" ]] && ! is_bad_ip "$value"; then
			candidate="$value"
		fi
	fi

	echo "$candidate"
}

if [[ -z "${BEACH_ICE_PUBLIC_IP:-}" ]]; then
	host_ip=$(detect_host_ip)
	if [[ -n "$host_ip" ]]; then
		export BEACH_ICE_PUBLIC_IP="$host_ip"
		export BEACH_ICE_PUBLIC_HOST="$host_ip"
		export BEACH_ICE_PUBLIC_AUTO=1
	fi
fi

if [[ -n "${BEACH_ICE_PUBLIC_IP:-}" ]]; then
	export BEACH_HOST_LAN_IP="${BEACH_ICE_PUBLIC_IP}"
fi
