# Beach Terminal Sharing Protocol Specification

## Overview

The Beach protocol enables efficient, real-time terminal state synchronization between a server and multiple clients. The protocol is designed to minimize bandwidth, support various viewing modes, and provide robust error recovery.

## Core Concepts

### 1. Subscriptions
Clients establish subscriptions to receive terminal state updates. Each subscription defines:
- **View dimensions** (width × height) for the client's display
- **View mode** (realtime, historical, or anchored)
- **Update strategy** (deltas, snapshots, or hybrid)

### 2. View Deduplication
The session broker maintains a registry of unique GridViews. Multiple clients requesting identical views (same dimensions, mode, position) share the same computed GridView, reducing server computation.

### 3. State Synchronization
The protocol ensures clients remain synchronized through:
- Initial snapshot transmission
- Incremental delta updates
- Sequence numbering for ordering
- Checksums for verification

## Message Types

### Client → Server Messages

```typescript
// Subscribe to a terminal view
Subscribe {
  subscription_id: string,      // Client-generated unique ID
  dimensions: {
    width: u16,
    height: u16
  },
  mode: ViewMode,               // "realtime" | "historical" | "anchored"
  position?: ViewPosition,      // For historical/anchored modes
  compression?: "gzip" | "none"
}

// Modify existing subscription
ModifySubscription {
  subscription_id: string,
  dimensions?: { width: u16, height: u16 },
  mode?: ViewMode,
  position?: ViewPosition
}

// Unsubscribe from a view
Unsubscribe {
  subscription_id: string
}

// Send terminal input (only from controlling clients)
TerminalInput {
  data: bytes,
  echo_local?: boolean          // Optimistic local echo hint
}

// Request specific state
RequestState {
  subscription_id: string,
  type: "snapshot" | "checkpoint",
  sequence?: u64                 // For requesting from specific point
}

// Acknowledge receipt (for critical messages)
Acknowledge {
  message_id: string,
  checksum?: u32                 // Optional state verification
}

// Control messages
Control {
  type: "pause" | "resume" | "clear_history",
  subscription_id?: string       // If omitted, applies to all
}

// Heartbeat
Ping {
  timestamp: i64,
  subscriptions: string[]        // Active subscription IDs for verification
}
```

### Server → Client Messages

```typescript
// Initial state snapshot
Snapshot {
  subscription_id: string,
  sequence: u64,                 // Starting sequence number
  grid: Grid,                     // Full grid state
  timestamp: i64,
  checksum: u32
}

// Incremental updates
Delta {
  subscription_id: string,
  sequence: u64,                 // Monotonically increasing
  changes: GridDelta,            // Sparse changes only
  timestamp: i64
}

// Batched deltas for efficiency
DeltaBatch {
  subscription_id: string,
  start_sequence: u64,
  end_sequence: u64,
  deltas: GridDelta[],          // Multiple deltas in order
  compressed?: boolean
}

// View transition (when switching modes)
ViewTransition {
  subscription_id: string,
  from_mode: ViewMode,
  to_mode: ViewMode,
  delta?: GridDelta,            // Delta from old to new view
  snapshot?: Grid               // Full snapshot if delta too large
}

// Subscription confirmation
SubscriptionAck {
  subscription_id: string,
  status: "active" | "pending" | "shared",
  shared_with?: string[]        // Other clients sharing this view
}

// Error messages
Error {
  subscription_id?: string,
  code: ErrorCode,
  message: string,
  recoverable: boolean,
  retry_after?: u32             // Seconds to wait before retry
}

// Heartbeat response
Pong {
  timestamp: i64,
  server_sequence: u64,         // Current server sequence
  subscriptions: {
    [id: string]: {
      sequence: u64,
      mode: ViewMode
    }
  }
}

// Notification
Notify {
  type: "dimension_change" | "mode_change" | "session_ending",
  subscription_id?: string,
  details: any
}
```

## View Modes and Positions

```typescript
ViewMode = "realtime"           // Follow current terminal output
         | "historical"         // View at specific point in time
         | "anchored"          // Anchored to line number

ViewPosition = {
  time?: i64,                   // Unix timestamp for historical
  line?: u64,                   // Line number for anchored
  offset?: i32                  // Relative offset from anchor
}
```

## Protocol Flow

### 1. Initial Connection
```
Client                          Server
  |                                |
  |------ Subscribe -------->      |
  |                                |
  |<----- SubscriptionAck ----     |
  |                                |
  |<----- Snapshot ----------     |
  |                                |
  |------ Acknowledge ------>      |
  |                                |
  |<----- Delta ------------>      |
  |<----- Delta ------------>      |
  |<----- DeltaBatch ------->      |
```

### 2. View Mode Switching
```
Client                          Server
  |                                |
  |--- ModifySubscription -->      |  (historical → realtime)
  |                                |
  |<--- ViewTransition ------      |  (with delta or snapshot)
  |                                |
  |<----- Delta ------------>      |  (resume realtime updates)
```

### 3. Recovery After Disconnection
```
Client                          Server
  |     (reconnect)                |
  |                                |
  |------ RequestState ----->      |  (last_sequence: 1234)
  |                                |
  |<----- DeltaBatch --------      |  (missed deltas 1235-1250)
  |                                |
  |<----- Delta ------------>      |  (resume normal flow)
```

## Optimization Strategies

### 1. Subscription Pooling
```
Session Broker maintains:
  ViewRegistry {
    "80x24:realtime": {
      view: GridView,
      subscribers: ["client1", "client2", "client3"]
    },
    "120x40:historical:12345": {
      view: GridView,
      subscribers: ["client4"]
    }
  }
```

### 2. Delta Compression
- Small deltas sent immediately
- Large deltas batched and compressed
- Fallback to snapshot if delta > 50% of grid

### 3. Adaptive Sync
- High-frequency updates batched during rapid changes
- Immediate transmission during idle periods
- Client can request sync rate adjustment

## Error Handling

### Error Codes
```
1xxx - Protocol errors
  1001: Invalid message format
  1002: Unknown subscription
  1003: Sequence mismatch

2xxx - State errors  
  2001: Checksum mismatch
  2002: Invalid dimensions
  2003: History not available

3xxx - Permission errors
  3001: Input not allowed
  3002: View not permitted

4xxx - Resource errors
  4001: Too many subscriptions
  4002: Rate limit exceeded

5xxx - Server errors
  5001: Internal error
  5002: Session ending
```

### Recovery Procedures

1. **Checksum Mismatch**: Client requests full snapshot
2. **Sequence Gap**: Client requests missing deltas or snapshot
3. **Subscription Lost**: Client resubscribes with same ID
4. **Network Interruption**: Client resumes from last sequence

## Security Considerations

- Subscriptions validated against session permissions
- Input sanitized before processing
- Rate limiting per client
- Resource limits for subscription count and dimensions

## Future Extensions

- **Collaborative Cursors**: Multiple cursor positions for collaboration
- **Annotations**: Overlay annotations without modifying terminal state
- **Selective Updates**: Subscribe to specific regions of the grid
- **Predictive Echo**: Client-side prediction for low-latency feel

## Concrete Examples

### Example 1: Simple Subscription and Resize

**Scenario**: Client connects with 80×24 terminal, then resizes to 120×40.

```json
// 1. Client subscribes
→ { "type": "subscribe", "subscription_id": "client-abc", "dimensions": {"width": 80, "height": 24}, "mode": "realtime" }
← { "type": "subscription_ack", "subscription_id": "client-abc", "status": "active" }
← { "type": "snapshot", "subscription_id": "client-abc", "sequence": 1000, "grid": {...}, "checksum": 0xABCD }
→ { "type": "acknowledge", "message_id": "client-abc", "checksum": 0xABCD }

// 2. Ongoing updates
← { "type": "delta", "subscription_id": "client-abc", "sequence": 1001, "changes": {...} }
← { "type": "delta", "subscription_id": "client-abc", "sequence": 1002, "changes": {...} }

// 3. Client resizes window
→ { "type": "modify_subscription", "subscription_id": "client-abc", "dimensions": {"width": 120, "height": 40} }
← { "type": "view_transition", "subscription_id": "client-abc", "delta": { "dimension_change": {...}, "cell_changes": [...] } }

// 4. Updates continue with new dimensions
← { "type": "delta", "subscription_id": "client-abc", "sequence": 1003, "changes": {...} }
```

### Example 2: Multiple Clients with View Pooling

**Scenario**: Three clients connect with identical 80×24 dimensions - demonstrating subscription pooling.

```json
// Client A subscribes
→ A: { "type": "subscribe", "subscription_id": "client-A", "dimensions": {"width": 80, "height": 24}, "mode": "realtime" }
← A: { "type": "subscription_ack", "subscription_id": "client-A", "status": "active" }

// Client B subscribes with same dimensions
→ B: { "type": "subscribe", "subscription_id": "client-B", "dimensions": {"width": 80, "height": 24}, "mode": "realtime" }
← B: { "type": "subscription_ack", "subscription_id": "client-B", "status": "shared", "shared_with": ["client-A"] }

// Client C subscribes with same dimensions
→ C: { "type": "subscribe", "subscription_id": "client-C", "dimensions": {"width": 80, "height": 24}, "mode": "realtime" }
← C: { "type": "subscription_ack", "subscription_id": "client-C", "status": "shared", "shared_with": ["client-A", "client-B"] }

// Server computes ONE GridView, sends to all three
← A,B,C: { "type": "delta", "subscription_id": "*", "sequence": 2000, "changes": {...} }

// Client B changes dimensions (leaves pool)
→ B: { "type": "modify_subscription", "subscription_id": "client-B", "dimensions": {"width": 100, "height": 30} }
← B: { "type": "subscription_ack", "subscription_id": "client-B", "status": "active" }
← B: { "type": "view_transition", "subscription_id": "client-B", "delta": {...} }

// Now A and C share one view, B has its own
← A,C: { "type": "delta", "subscription_id": "*", "sequence": 2001, "changes": {...} }
← B: { "type": "delta", "subscription_id": "client-B", "sequence": 2001, "changes": {...} }
```

### Example 3: Historical Browsing with Return to Realtime

**Scenario**: Client scrolls back through history then returns to live view.

```json
// 1. Client in realtime mode
→ { "type": "subscribe", "subscription_id": "client-xyz", "dimensions": {"width": 80, "height": 24}, "mode": "realtime" }
← { "type": "snapshot", "subscription_id": "client-xyz", "sequence": 3000, "grid": {...} }

// 2. User scrolls back to view 5 minutes ago
→ { "type": "modify_subscription", "subscription_id": "client-xyz", "mode": "historical", "position": {"time": 1699123000000} }
← { "type": "view_transition", "subscription_id": "client-xyz", "from_mode": "realtime", "to_mode": "historical",
    "snapshot": {...} }  // Full snapshot of historical state

// 3. User scrolls through history
→ { "type": "modify_subscription", "subscription_id": "client-xyz", "position": {"time": 1699123060000} }
← { "type": "view_transition", "subscription_id": "client-xyz", "delta": {...} }  // Delta from previous historical view

// 4. User returns to realtime
→ { "type": "modify_subscription", "subscription_id": "client-xyz", "mode": "realtime" }
← { "type": "view_transition", "subscription_id": "client-xyz", "from_mode": "historical", "to_mode": "realtime",
    "delta": {...} }  // Large delta or snapshot to catch up
← { "type": "delta", "subscription_id": "client-xyz", "sequence": 3050, "changes": {...} }  // Resume realtime
```

### Example 4: Network Interruption and Recovery

**Scenario**: Client loses connection and needs to recover state.

```json
// 1. Normal operation
← { "type": "delta", "subscription_id": "client-123", "sequence": 4000, "changes": {...} }
← { "type": "delta", "subscription_id": "client-123", "sequence": 4001, "changes": {...} }

// 2. Network interruption occurs
// ... time passes, changes accumulate on server ...

// 3. Client reconnects and requests recovery
→ { "type": "request_state", "subscription_id": "client-123", "sequence": 4001 }  // Last known sequence

// 4. Server sends missed updates
← { "type": "delta_batch", "subscription_id": "client-123",
    "start_sequence": 4002, "end_sequence": 4025,
    "deltas": [...], "compressed": true }  // 24 deltas compressed

// 5. Normal operation resumes
← { "type": "delta", "subscription_id": "client-123", "sequence": 4026, "changes": {...} }
```

### Example 5: High-Frequency Output with Batching

**Scenario**: Terminal generates rapid output (e.g., build logs), demonstrating adaptive batching.

```json
// 1. Rapid changes detected - server starts batching
// Instead of sending 100 individual deltas...

// 2. Server sends batched update
← { "type": "delta_batch", "subscription_id": "client-789",
    "start_sequence": 5000, "end_sequence": 5099,
    "deltas": [...100 deltas...], "compressed": true }

// 3. Output slows down - return to individual deltas
← { "type": "delta", "subscription_id": "client-789", "sequence": 5100, "changes": {...} }
← { "type": "delta", "subscription_id": "client-789", "sequence": 5101, "changes": {...} }
```

## Implementation Architecture

### Overview

The implementation uses a three-layer architecture with clear separation of concerns. The Session Broker (living in `src/session/multiplexer.rs`) acts as the intelligent routing layer between clients and the terminal server.

```
┌─────────────────────────────────────────────────────────────┐
│                         Clients                              │
│  (Rendering, User Input, View State)                        │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                 Session Broker                               │
│           (src/session/multiplexer.rs)                      │
│  (Routing, Multiplexing, Subscription Management,           │
│   View Registry, Connection Management)                     │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                    Terminal Server                           │
│  (Terminal State, GridView Computation, Delta Generation)   │
└─────────────────────────────────────────────────────────────┘
```

### Module Organization

```
src/
├── session/
│   ├── mod.rs                    # Public session API
│   ├── multiplexer.rs           # SessionBroker implementation
│   ├── subscription_pool.rs    # View registry and pooling logic
│   ├── message_router.rs       # Client/server message routing
│   └── view_registry.rs        # ViewKey and deduplication
├── protocol/
│   ├── mod.rs                   # Protocol types and serialization
│   ├── client_messages.rs      # Client → Server message types
│   ├── server_messages.rs      # Server → Client message types
│   └── protocol_spec.txt       # This specification
└── server/
    └── terminal_state/          # Terminal server implementation
```

### Component Responsibilities

#### 1. Terminal Server
**Responsibility**: Maintain terminal state and compute views

```rust
// Server only knows about GridView requests, not individual clients
interface TerminalServer {
    // Session tells server which views are needed
    fn register_view(view_id: ViewId, dimensions: Dimensions, mode: ViewMode) -> GridView;
    fn unregister_view(view_id: ViewId);
    
    // Server pushes updates to session
    fn on_terminal_change(callback: Fn(ViewId, GridDelta));
    
    // Compute transitions
    fn compute_transition(from_view: ViewId, to_view: ViewId) -> TransitionDelta;
    
    // Handle terminal input
    fn process_input(data: Vec<u8>);
}
```

#### 2. Session Broker (src/session/multiplexer.rs)
**Responsibility**: Route messages and manage subscriptions

The SessionBroker is the core intelligence of the protocol, living in `src/session/multiplexer.rs`. It acts as an intelligent multiplexer between multiple clients and the terminal server.

```rust
// src/session/multiplexer.rs
pub struct SessionBroker {
    // View registry for deduplication
    view_registry: HashMap<ViewKey, ViewInfo>,
    
    // Client subscription mapping
    subscriptions: HashMap<SubscriptionId, Subscription>,
    
    // View to subscriptions mapping (for pooling)
    view_subscribers: HashMap<ViewId, Vec<SubscriptionId>>,
    
    // Client connections
    clients: HashMap<ClientId, ClientConnection>,
    
    // Reference to terminal server
    terminal_server: Arc<Mutex<TerminalServer>>,
}

struct ViewInfo {
    view_id: ViewId,
    dimensions: Dimensions,
    mode: ViewMode,
    position: Option<ViewPosition>,
    current_sequence: u64,
    subscribers: HashSet<SubscriptionId>,
}

impl SessionBroker {
    // Client subscription management
    fn handle_subscribe(&mut self, client_id: ClientId, msg: Subscribe) {
        let view_key = ViewKey::from(&msg);
        
        // Check if view already exists
        if let Some(view_info) = self.view_registry.get(&view_key) {
            // Add client to existing view (pooling)
            view_info.subscribers.insert(msg.subscription_id);
            self.send_client(client_id, SubscriptionAck::shared(...));
        } else {
            // Create new view
            let view_id = self.server.register_view(...);
            self.view_registry.insert(view_key, ViewInfo::new(...));
            self.send_client(client_id, SubscriptionAck::active(...));
        }
        
        // Send initial snapshot
        let snapshot = self.server.get_snapshot(view_id);
        self.send_client(client_id, snapshot);
    }
    
    fn handle_modify_subscription(&mut self, client_id: ClientId, msg: ModifySubscription) {
        let old_view = self.subscriptions.get(&msg.subscription_id);
        let new_view_key = ViewKey::from(&msg);
        
        if old_view.key != new_view_key {
            // Remove from old view pool
            self.remove_from_view(old_view);
            
            // Add to new view pool (or create)
            self.add_to_view(new_view_key);
            
            // Compute and send transition
            let transition = self.server.compute_transition(old_view.id, new_view.id);
            self.send_client(client_id, ViewTransition { transition });
        }
    }
    
    // Server update distribution
    fn on_server_update(&mut self, view_id: ViewId, delta: GridDelta) {
        // Find all subscribers for this view
        if let Some(subscribers) = self.view_subscribers.get(&view_id) {
            let msg = Delta { delta, sequence: self.next_sequence() };
            
            // Send to all subscribers (efficient multicast)
            for subscription_id in subscribers {
                if let Some(client_id) = self.get_client(subscription_id) {
                    self.send_client(client_id, msg.clone());
                }
            }
        }
    }
}
```

#### 3. Client
**Responsibility**: Render terminal and handle user interaction

```rust
struct TerminalClient {
    subscription_id: SubscriptionId,
    current_grid: Grid,
    current_sequence: u64,
    dimensions: Dimensions,
    mode: ViewMode,
}

impl TerminalClient {
    fn handle_resize(&mut self, new_dimensions: Dimensions) {
        self.session.send(ModifySubscription {
            subscription_id: self.subscription_id,
            dimensions: new_dimensions,
        });
    }
    
    fn handle_scroll(&mut self, position: ScrollPosition) {
        let mode = if position.is_bottom() {
            ViewMode::Realtime
        } else {
            ViewMode::Historical
        };
        
        self.session.send(ModifySubscription {
            subscription_id: self.subscription_id,
            mode,
            position: Some(position.to_view_position()),
        });
    }
    
    fn handle_snapshot(&mut self, msg: Snapshot) {
        self.current_grid = msg.grid;
        self.current_sequence = msg.sequence;
        self.render();
    }
    
    fn handle_delta(&mut self, msg: Delta) {
        if msg.sequence == self.current_sequence + 1 {
            self.current_grid.apply_delta(msg.changes);
            self.current_sequence = msg.sequence;
            self.render();
        } else {
            // Sequence mismatch - request recovery
            self.request_recovery();
        }
    }
}
```

### Key Implementation Details

#### View Registry Key Structure
```rust
// src/session/view_registry.rs
// Efficient view deduplication
#[derive(Hash, Eq, PartialEq)]
pub struct ViewKey {
    dimensions: (u16, u16),
    mode: ViewMode,
    position: Option<ViewPosition>,  // None for realtime
}
```

#### Message Routing
```rust
// src/session/message_router.rs
// Session broker routes all messages
pub enum Route {
    ClientToServer(ClientId, Message),
    ServerToClient(ViewId, Message),
    ServerToAllClients(ViewId, Message),  // Multicast for shared views
}
```

#### Subscription Pool Management
```rust
// src/session/subscription_pool.rs
pub struct SubscriptionPool {
    pools: HashMap<ViewKey, Vec<SubscriptionId>>,
    subscription_views: HashMap<SubscriptionId, ViewKey>,
}

impl SubscriptionPool {
    pub fn join_pool(&mut self, sub_id: SubscriptionId, view_key: ViewKey) -> PoolStatus;
    pub fn leave_pool(&mut self, sub_id: SubscriptionId) -> Option<ViewKey>;
    pub fn get_pool_size(&self, view_key: &ViewKey) -> usize;
}
```

#### Subscription Lifecycle
```
1. Subscribe → Check pool → Create/Join view → Send snapshot
2. Modify → Leave old pool → Join new pool → Send transition
3. Unsubscribe → Leave pool → Destroy view if empty
```

### Benefits of This Architecture

1. **Efficient Resource Usage**: Server computes each unique view once
2. **Clean Separation**: Each component has a single responsibility
3. **Scalability**: Session can be distributed/replicated
4. **Flexibility**: Easy to add new view modes or message types
5. **Testability**: Each component can be tested independently
6. **Performance**: Multicast updates to pooled subscribers
7. **Maintainability**: Clear interfaces between components