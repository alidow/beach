# Private Beach Vision

## Overview
- Extend open-source `apps/beach` foundation with a paid "Private Beach" orchestration layer that unifies terminals, screen shares, and MCP-enabled automation.
- Provide a single, customizable cockpit where humans and AI agents monitor, control, and collaborate across multiple sessions with fine-grained access.
- Deliver durable collaboration primitives (authorization, storage, cross-session messaging) that unlock premium workflows while preserving self-hosting for core Beach.

## Product Pillars
- **Unified Workspace:** Responsive grid layout for terminals, Beach Cabana streams, and future widgets; drag-resize, presets, and multi-view dashboards.
- **Access Control:** Integration with Beach Gate + OIDC/Clerk; per-private-beach ACLs, shareable links, and group management with admins.
- **Agent Mediation:** Designate Beach CLI or external MCP agents as coordinators that can observe, trigger, or automate actions across member sessions; Beach Manager enforces policy and auditing around every automation path.
- **Zero-Trust Control Plane:** Beach Manager validates every action, issues controller leases, and provides automation onboarding while assuming infrastructure compromise is possible.
- **Shared State:** Persistent file storage and low-latency Redis-backed key-value store exposed through MCP for coordination and auditing; v1 favors simple last-write-wins semantics, small blobs, and per-beach quotas over complex transactions.
- **Observability & Events:** Real-time telemetry, session health indicators, and event bus hooks for alerts, automations, and future billing signals.

## Identity & Access Model
- **Authentication:** OIDC/Clerk remains the primary identity provider for humans; Beach CLI sessions reuse device flow credentials. Successful logins yield an identity token that never leaves Beach Gate.
- **Authorization:** Beach Gate issues short-lived, scoped JWTs representing memberships, group roles, and feature entitlements. Private Beach manager trusts only Beach Gate–signed proofs.
- **Share Links:** Generated by the manager as signed, single-purpose invitations that embed a Beach Gate claim (`private_beach_id`, `role`, `expiry`). Guests exchange the link token with Beach Gate to obtain a read-only session token; revocation is handled server-side.
- **Groups & Roles:** Postgres stores group membership and role assignments; Beach Gate evaluates policies and includes resulting claims in its tokens so downstream services enforce them uniformly.
- **Agent Credentials:** Non-human agents authenticate via Beach Gate service accounts. Tokens are scoped to specific private beaches and capabilities (e.g., `control:session`, `read:state`).
- **Audit & Revocation:** Manager persists issued tokens/share links and calls Beach Gate to revoke or rotate them when membership changes, ensuring a single source of truth for access decisions.

## System Architecture (Draft)
```
┌────────────────────────────────────────────────────────────┐
│               Private Beach Surfer (Next.js)              │
│  UI, Dashboard Layouts, Auth, Manager Workflows            │
└───────────────┬──────────────────────┬──────────────────────┘
                │                      │
                ▼                      ▼
       ┌───────────────┐      ┌─────────────────┐
       │ Beach Manager │      │ Event + State Bus │
       │ (Rust Control │      │ (Redis Streams,   │
       │  Plane + MCP) │      │ Postgres, MQ)     │
       └───────────────┬──────┴─────────┬────────┘
                       │                │
         ┌─────────────▼─────┐  ┌───────▼──────────┐
         │ Beach Buggy       │  │ Shared Storage    │
         │ Harnesses         │  │ (Redis KV,        │
         │ (apps/beach,      │  │ Object/File store)│
         │ beach-cabana, etc)│  │                  │
         └─────────────┬─────┘  └───────┬──────────┘
                       │                │
               ┌───────▼──────┐   ┌─────▼──────────┐
               │ Beach Gate   │   │ External Agents │
               │ Auth Service │   │ (MCP)           │
               └──────────────┘   └────────────────┘
```
- **Front-end:** Next.js + Tailwind + shadcn component library; multi-viewport layout manager; live WebRTC/WebSocket feeds.
- **Beach Manager Control Plane:** Rust service that validates entitlements, manages the session registry, issues controller leases, bootstraps automation agents (prompt templates, MCP bridge config), enforces zero-trust policy, and persists audit events.
- **Beach Buggy Harness Layer:** Optional Rust crate that listens to the host’s diff stream and emits derived views (semantic text, motion vectors, etc.) on demand. Baseline connectivity and contention handling stay inside the core `apps/beach` runtime. See `docs/private-beach/webrtc-refactor/plan.md`.
- **Data Layer:** Postgres for relational state (organizations, beaches, memberships, automation policies); Redis for ephemeral state, KV, and pub/sub triggers; optional S3-compatible object store for file persistence.
- **Integration Points:** `beach-surfer`, `apps/beach`, `beach-cabana`, `apps/private-beach`, Beach Gate, and third-party MCP agents.

### Beach Manager Responsibilities
- **Session Registry:** authoritative inventory of sessions, harness metadata, controller leases, and layout assignments for each private beach.
- **Policy Engine:** enforces org-level rules, rate limits, role-based access, and zero-trust assumptions; rejects actions outside declared scopes.
- **Automation Onboarding:** verifies agent entitlements, generates task-specific prompt packs, wires MCP bridges or HTTP adapters, and rotates credentials.
- **Telemetry & Audit:** captures controller events, state access logs, and automation outcomes; emits signals to billing, alerting, and analytics.
- **Transport Coordination:** keeps WebRTC as the golden path, only invoking TURN/WSS when an authenticated, entitled account requires it, and negotiates extra data channels (e.g., harness transforms) without altering the base protocol.

## Implementation Roadmap (High-Level)
1. **Foundations**
   - Formalize product boundaries: open-source core vs. paid manager capabilities.
   - Define API contracts between Private Beach manager and existing Beach clients.
   - Catalog auth flows (OIDC login, Beach Gate tokens, share links).
2. **Workspace MVP**
   - Next.js dashboard consuming mocked session data.
   - Implement session discovery endpoints and websocket updates.
   - Ship basic drag-resize layout persisted per user/private beach.
3. **Authorization & Sharing**
   - CRUD for private beaches, groups, memberships.
   - Shareable link issuance + revocation; enforcement layers in backend + clients.
   - Audit log groundwork for future billing/compliance.
4. **Shared State Layer**
   - Provision Redis namespace per private beach; expose MCP endpoints for read/write.
   - Provide file storage abstraction (object store + simple browser UI).
5. **Agent Orchestration**
   - Register agent-capable sessions; grant scoped tokens for control APIs.
   - Implement cross-session command dispatch and event triggers.
   - Deliver manager onboarding workflows (prompt packs, MCP bridge catalogs, scoped credential issuance).
6. **Operational Hardening**
   - Observability dashboard, rate limiting, billing hooks, multi-tenant isolation.
   - Reliability testing across WebRTC/WS edges; failover strategies.

## Critical Questions & Open Topics
- **Tenant Isolation:** What hard boundaries (network, data) are required between private beaches to satisfy enterprise expectations?
- **Session Identity:** How do sessions identify themselves to the manager (MCP handshake, JWT, mutual TLS)? How is trust bootstrapped?
- **Layout Sync Semantics:** Should layouts be per-user, per-private-beach, or shared with optional overrides? How do we resolve conflicts?
- **Agent Permissions:** What guardrails exist when granting an agent control over other sessions? Do we need scoped capabilities or approval workflows?
- **Offline & History:** Is historical playback or transcript storage part of the paid value? How long should data persist?
- **Billing Model:** Seat-based, usage-based, or per-private-beach pricing? How does this integrate with authentication and invite flows?
- **Extensibility:** How do we let third parties add widgets or automations without compromising security or UX?
- **Deployment Modes:** Will Private Beach only run on Beach Cloud, or will customers self-host? How does that affect packaging/licensing?
- **Agent Attestation:** Can we verify AI manager identity/runtime (template trust, sandboxing) before granting orchestration privileges?
